Certified Kubernetes Application Developer
Build Your Practice Cluster
On all 3 servers
First, set up the Docker and Kubernetes repositories:
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

sudo add-apt-repository    "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"

curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

cat << EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF

Install Docker and Kubernetes packages:
Note that if you want to use a newer version of Kubernetes, change the version installed for kubelet, kubeadm, and kubectl. Make sure all three use the same version.
Note: There is currently a bug in Kubernetes 1.13.4 (and earlier) that can cause problems installaing the packages. Use 1.13.5-00 to avoid this issue.

sudo apt-get update
sudo apt-get install -y docker-ce=18.06.1~ce~3-0~ubuntu kubelet=1.13.5-00 kubeadm=1.13.5-00 kubectl=1.13.5-00
sudo apt-mark hold docker-ce kubelet kubeadm kubectl

Enable iptables bridge call:
echo "net.bridge.bridge-nf-call-iptables=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

On the Kube master server
Initialize the cluster:
sudo kubeadm init --pod-network-cidr=10.244.0.0/16

Set up local kubeconfig:
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

Install Flannel networking:
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml

On each Kube node server
Join the node to the cluster:
sudo kubeadm join $controller_private_ip:6443 --token $token --discovery-token-ca-cert-hash $hash

On the Kube master server
Verify that all nodes are joined and ready:
kubectl get nodes

You should see all three servers with a status of Ready:
NAME                      STATUS   ROLES    AGE   VERSION
wboyd1c.mylabserver.com   Ready    master   54m   v1.13.4
wboyd2c.mylabserver.com   Ready    <none>   49m   v1.13.4
wboyd3c.mylabserver.com   Ready    <none>   49m   v1.13.4

Kubernetes API Primitives
also called Kubernetes Objects
Data objects that represent the state of the cluster
https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
kubectl api-resources -o name  shows all resources in a cluster

kubectl get pods -n kube-system

kubectl get nodes

kubectl get nodes $node_name

kubectl get nodes $node_name -o yaml

kubectl describe node $node_name

spec - the desired state of the object
status- the current state of the object

Creating Pods
Pods are the basic building blocks of any application running in Kube.
Consists of one or more containers and a set of resources shared by those containers.
All containers are part of a pod

Create a new yaml file to contain the pod definition. Use whatever editor you like, but we used vi:
vi my-pod.yml
my-pod.yml:

apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']

Create a pod from the yaml definition file:
kubectl create -f my-pod.yml

Edit a pod by updating the yaml definiton and re-applying it:
kubectl apply -f my-pod.yml

You can also edit a pod like this:
kubectl edit pod my-pod

You can delete a pod like this:
kubectl delete pod my-pod

Namespaces
provide a way to keep your objects organized with the cluster.
Every object belongs to a namespace.
When no namespace is specified, the cluster will assume default namespace.
When creating an object, you can assign it to a namespace by specifying a namespace in the metadata.

You can get a list of the namespaces in the cluster like this:
kubectl get namespaces

You can also create your own namespaces.
kubectl create ns my-ns

To assign an object to a custom namespace, simply specify its metadata.namespace attribute.
apiVersion: v1
kind: Pod
metadata:
  name: my-ns-pod
  namespace: my-ns
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']

Use the -n flag to specify a namespace when using commands like kubectl get.
kubectl get pods -n my-ns

You can also use -n to specify a namespace when using kubectl describe.
kubectl describe pod my-ns-pod -n my-ns

Basic Container Configuration
You can specify the command that will be used to run a container in the Pod spec.
This will override any built-in default command specified by the container image.

You can specify custom commands for your containers.
apiVersion: v1
kind: Pod
metadata:
  name: my-command-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['echo']
  restartPolicy: Never

You can also add custom arguments like so:
apiVersion: v1
kind: Pod
metadata:
  name: my-args-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['echo']
    args: ['This is my custom argument']
  restartPolicy: Never

Here is a pod with a containerPort:
apiVersion: v1
kind: Pod
metadata:
  name: my-containerport-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: nginx
    ports:
    - containerPort: 80

Allows other containers on cluster to connect to nginx pod on port 80.

You can check the status of your pods at any time with kubectl get pods.

Hands-On Lab: Creating Kubernetes Pods
Your company is getting ready to launch a new website, and they need you to set up an nginx web server in their Kubernetes cluster.
The nginx server will need to be accessible via network in the future, so you will need to expose port 80 as a containerPort for the nginx container.
Your team has also asked you to ensure that nginx runs in quiet mode for the time being to cut down on unnecessary log output.
You can do this by setting the command to nginx and passing the following arg to the container: -g daemon off; -q.
As this nginx server belongs to the Web team, you will need to create it in the team's web namespace.

To summarize:
Use the nginx container image.
The container needs a containerPort of 80.
Set the command to nginx
Pass in the -g daemon off; -q args to run nginx in quiet mode.
Create the pod in the web namespace.
Once the pod is created, you should be able to find it with kubectl get pods -n web. Once the pod is created, you can get more information about its current status with kubectl describe pod nginx -n web.

nginx.yaml
apiVersion:v1
kind: Pod
metadata:
  name: nginx
  namespace: web
spec:
  containers:
  - name: nginx
    image: nginx
    command: ["nginx"]
    args: ["-g", "daemon off;", "-q"]
    ports:
    - containerPort: 80

kubectl create -f nginx.yaml
kubectl get pods -n web

ConfigMaps
Kubernetes object that stores configuration data in a key-value format.
This config data can then be used to config software running in a container
by referencing the configmap in the pod spec

Here's an example of of a yaml descriptor for a ConfigMap containing some data:
apiVersion: v1
kind: ConfigMap
metadata:
   name: my-config-map
data:
   myKey: myValue
   anotherKey: anotherValue

Passing ConfigMap data to a container as an environment variable looks like this:
apiVersion: v1
kind: Pod
metadata:
  name: my-configmap-pod
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', "echo $(MY_VAR) && sleep 3600"]
    env:
    - name: MY_VAR
      valueFrom:
        configMapKeyRef:
          name: my-config-map
          key: myKey

It's also possible to pass ConfigMap data to containers, in the form of file using a mounted volume, like so:
apiVersion: v1
kind: Pod
metadata:
  name: my-configmap-volume-pod
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', "echo $(cat /etc/config/myKey) && sleep 3600"]
    volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: my-config-map

In the lesson, we'll also use the following commands to explore how the ConfigMap data interacts with pods and containers:
kubectl logs my-configmap-pod

kubectl logs my-configmap-volume-pod

kubectl exec my-configmap-volume-pod -- ls /etc/config

kubectl exec my-configmap-volume-pod -- cat /etc/config/myKey






